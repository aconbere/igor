#!/usr/bin/env python
import sys
from os import path, makedirs
import optparse
from optparse import OptionParser

sys.path.append(path.abspath("."))

from igor.project_parser import ProjectParser
from igor import version

parser = OptionParser(
    usage = "igor COMMAND [OPTIONS]",
    version = version,
    add_help_option = False,
    )

parser.add_option(
    '-h', '--help',            
    dest='help',               
    action='store_true',       
    help='Show help') 

#parser.add_option(
#    '-v', '--verbose',
#    dest='verbose',
#    action='count',
#    default=0,
#    help='Give more output')
#
#parser.add_option(
#    '-q', '--quiet',
#    dest='quiet',
#    action='count',
#    default=0,
#    help='Give less output')
#
#parser.add_option(
#    '--log',
#    dest='log',
#    metavar='FILENAME',
#    help='Log file where a complete (maximum verbosity) record will be kept')


_commands = {}

class Command(object):
    name = None
    usage = None

    def __init__(self):
        assert self.name
        self.parser = optparse.OptionParser(
            usage=self.usage,
            prog='%s %s' % (sys.argv[0], self.name),
            version=parser.version)
        _commands[self.name] = self

    def main(self, complete_args, args, initial_options):
        options, args = self.parser.parse_args(args)
        self.run(options, args)

class HelpCommand(Command):
    name = 'help'
    usage = '%prog'
    summary = 'Show available commands'

    def run(self, options, args):
        if args:
            command = args[0]
            if command not in _commands:
                raise Exception('No command with the name: %s' % command)

            command = _commands[command]
            command.parser.print_help()
            return

        parser.print_help()

        print('\nCommands available:')
        commands = list(set(_commands.values()))
        commands.sort(key=lambda x: x.name)
        for command in commands:
            print '  %s: %s' % (command.name, command.summary)

HelpCommand()

class InitCommand(Command):
    name = "init"
    usage = "%prog [OPTIONS] INITIAL_REPOSITORY"
    summary = "Initialize a directory for use as an Igor project"

    standard_directories = ["_posts",
                            "_templates",
                            "_media",
                            "_media/css",
                            "_media/js",
                            "_media/img",]
    files = {
        "config.yaml": """\
summary_length: 0 # number of lines to include in a summary, 0 indicates no summary
publish_directory: "~/blog/" # the path to where you want to output your blog
blog_uri: "/" # uri to the root of your blog, used to construct links""",

        "_posts/welcome.txt": """\
Welcome to your Igor blog

to start using igor, add any text file to /your/blog/_posts/ or edit this one.""",

        "_templates/post.html": """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
        <title>{{ doc.title }}</title>
</head>

<body>
    <div id="content">
        <h1>{{ doc.title }}</h1>
        <p>{{ doc.published_on }}</p>
        {{ doc.body }}
    </div>
</body>

</html>""",

        "_templates/main.html": """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
        <title>{{ title }}</title>
</head>

<body>
    <div id="content">
        {% for post in posts %}
        <div id="post">
            <h2><a href="{{ link_to(post.slug) }}">{{ post.title }}</a></h2>
            <p>{{ post.published_on }}</p>
            {{ post.content }}
        </div>
        {% endfor %}
    </div>
</body>

</html>"""
    }

    def run(self, options, args):
        if not args:
            print(self.usage)

        out_path = path.abspath(path.expanduser(args[0]))

        if path.exists(out_path):
            print("Directory %s already exists" % out_path)
            sys.exit(1)

        makedirs(out_path)

        for directory in self.standard_directories:
            makedirs(path.join(out_path, directory))

        for file, content in self.files.iteritems():
            with open(path.join(out_path, file), 'w') as f:
                f.write(content)

InitCommand()

class PublishCommand(Command):
    name = "publish"
    usage = "%prog [OPTIONS] PROJECT_DIRECTORY [OUTPUT_DIRECTORY]"
    summary = "Publish a site given an igor repository"
    
    def run(self, options, args):
        if not args:
            print(self.usage)

        project_dir = args[0]
        output_dir = ""

        if len(args) == 2:
            output_dir  = args[1]

        ProjectParser(project_dir, output_dir).write()

PublishCommand()


def main(initial_args = None):
    if initial_args is None:
        initial_args = sys.argv[1:]
    options, args = parser.parse_args(initial_args)
    if options.help and not args:
        args = ['help']
    if not args:
        parser.error("You must give a command")
    command = args[0].lower()
    if command not in _commands:
        parser.error("No command by the name")
    command = _commands[command]
    return command.main(initial_args, args[1:], options)
        

if __name__ == "__main__":
    main()
